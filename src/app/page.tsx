"use client";
import { useState, useEffect } from "react";
import { Header } from "@/components/layouts/Header";
import { Sidebar } from "@/components/layouts/Sidebar";
import { DataGrid } from "@/components/shared/DataGrid";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useAppStore, DataRow, Filter } from "@/lib/store";
import { Loader2, Search, X } from "lucide-react";

/**
 * A robust, client-side filtering function.
 * It takes an array of data and an array of filter conditions generated by the AI.
 */
const applyFilters = (data: DataRow[], filters: Filter[]): DataRow[] => {
  if (!filters || filters.length === 0) return data;

  return data.filter((row) => {
    return filters.every((filter) => {
      const rowValue = row[filter.field];
      if (rowValue === undefined || rowValue === null) return false;

      // Use a switch statement to handle all the different comparison operators.
      switch (filter.operator) {
        // FIX: For all numeric comparisons, we ensure BOTH values are treated as Numbers.
        case "gt":
          return Number(rowValue) > Number(filter.value);
        case "lt":
          return Number(rowValue) < Number(filter.value);
        case "gte":
          return Number(rowValue) >= Number(filter.value);
        case "lte":
          return Number(rowValue) <= Number(filter.value);
        case "eq":
          return (
            String(rowValue).toLowerCase() == String(filter.value).toLowerCase()
          );
        case "neq":
          return (
            String(rowValue).toLowerCase() != String(filter.value).toLowerCase()
          );
        case "contains":
          if (typeof rowValue === "string") {
            return rowValue
              .split(",")
              .map((s) => s.trim())
              .includes(String(filter.value));
          }
          return false;
        default:
          return true;
      }
    });
  });
};

/**
 * The main page component for the Data Alchemist application.
 */
export default function Home() {
  // --- STATE MANAGEMENT ---
  const { clientData, workersData, tasksData } = useAppStore();
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [displayedClientData, setDisplayedClientData] = useState<DataRow[]>([]);
  const [displayedWorkersData, setDisplayedWorkersData] = useState<DataRow[]>(
    []
  );
  const [displayedTasksData, setDisplayedTasksData] = useState<DataRow[]>([]);

  // --- DATA SYNCHRONIZATION ---
  useEffect(() => {
    setDisplayedClientData(clientData);
    setDisplayedWorkersData(workersData);
    setDisplayedTasksData(tasksData);
  }, [clientData, workersData, tasksData]);

  // --- EVENT HANDLERS ---
  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      const clientSchema =
        clientData.length > 0 ? Object.keys(clientData[0]) : [];
      const workersSchema =
        workersData.length > 0 ? Object.keys(workersData[0]) : [];
      const tasksSchema = tasksData.length > 0 ? Object.keys(tasksData[0]) : [];

      const response = await fetch("/api/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: searchQuery,
          schemas: {
            clients: clientSchema,
            workers: workersSchema,
            tasks: tasksSchema,
          },
        }),
      });

      if (!response.ok)
        throw new Error(`API responded with status: ${response.status}`);

      const result = await response.json();
      console.log("Frontend: Received AI filter object:", result);

      const { target, filters } = result;
      if (target === "clients") {
        setDisplayedClientData(applyFilters(clientData, filters));
      } else if (target === "workers") {
        setDisplayedWorkersData(applyFilters(workersData, filters));
      } else if (target === "tasks") {
        setDisplayedTasksData(applyFilters(tasksData, filters));
      }
    } catch (error) {
      console.error("Frontend: Error during search:", error);
    } finally {
      setIsSearching(false);
    }
  };

  const handleClear = () => {
    setDisplayedClientData(clientData);
    setDisplayedWorkersData(workersData);
    setDisplayedTasksData(tasksData);
    setSearchQuery("");
  };

  // --- RENDER ---
  return (
    <div className="flex min-h-screen flex-col">
      <Header />
      <div className="flex flex-1">
        <Sidebar />
        <main className="flex-grow p-4">
          <div className="flex items-center gap-2 mb-4">
            <Input
              placeholder="Search data... (e.g., clients with priority > 3)"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") handleSearch();
              }}
            />
            <Button onClick={handleSearch} disabled={isSearching}>
              {isSearching ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Search className="h-4 w-4" />
              )}
            </Button>
            <Button variant="ghost" onClick={handleClear}>
              <X className="h-4 w-4" />
            </Button>
          </div>

          <Tabs defaultValue="clients" className="w-full">
            <TabsList className="mb-4">
              <TabsTrigger value="clients">
                Clients ({displayedClientData.length})
              </TabsTrigger>
              <TabsTrigger value="workers">
                Workers ({displayedWorkersData.length})
              </TabsTrigger>
              <TabsTrigger value="tasks">
                Tasks ({displayedTasksData.length})
              </TabsTrigger>
            </TabsList>
            <TabsContent value="clients">
              <DataGrid rowData={displayedClientData} fileType="client" />
            </TabsContent>
            <TabsContent value="workers">
              <DataGrid rowData={displayedWorkersData} fileType="workers" />
            </TabsContent>
            <TabsContent value="tasks">
              <DataGrid rowData={displayedTasksData} fileType="tasks" />
            </TabsContent>
          </Tabs>
        </main>
      </div>
    </div>
  );
}
