"use client";
import { useState, useEffect } from "react";
import { Header } from "@/components/layouts/Header";
import { Sidebar } from "@/components/layouts/Sidebar";
import { DataGrid } from "@/components/shared/DataGrid";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useAppStore, DataRow } from "@/lib/store";
import { Loader2, Search, X } from "lucide-react";

/**
 * A robust, client-side filtering function.
 * It takes an array of data and an array of filter conditions generated by the AI.
 * @param data The original data array to be filtered.
 * @param filters An array of filter objects from the AI response.
 * @returns A new array containing only the rows that match all filter conditions.
 */
const applyFilters = (data: DataRow[], filters: any[]): DataRow[] => {
  // If there are no filters, no need to do any work, just return the original data.
  if (!filters || filters.length === 0) return data;

  // Filter the data array. A row is kept if it passes every filter condition.
  return data.filter((row) => {
    // '.every()' is used to ensure a row meets ALL filter criteria (acts like an "AND" condition).
    return filters.every((filter) => {
      const rowValue = row[filter.field];
      // If a row doesn't have the field we're trying to filter on, it should be excluded.
      if (rowValue === undefined) return false;

      // Use a switch statement to handle all the different comparison operators from the AI.
      switch (filter.operator) {
        case "gt":
          return rowValue > filter.value;
        case "lt":
          return rowValue < filter.value;
        case "gte":
          return rowValue >= filter.value;
        case "lte":
          return rowValue <= filter.value;
        case "eq":
          return (
            String(rowValue).toLowerCase() == String(filter.value).toLowerCase()
          );
        case "neq":
          return (
            String(rowValue).toLowerCase() != String(filter.value).toLowerCase()
          );
        case "contains":
          // The 'contains' operator is special for checking membership in a comma-separated list.
          if (typeof rowValue === "string") {
            return rowValue
              .split(",")
              .map((s) => s.trim())
              .includes(String(filter.value));
          }
          return false;
        default:
          return true;
      }
    });
  });
};

/**
 * The main page component for the Data Alchemist application.
 * This component serves as the central hub, managing the UI layout,
 * state for displayed data, and handling user interactions like search.
 */
export default function Home() {
  // --- STATE MANAGEMENT ---

  // 1. Master Data State: Get the original, unmodified data from our global Zustand store.
  // This is our "single source of truth".
  const { clientData, workersData, tasksData } = useAppStore();

  // 2. UI State: Local state variables for user interactions.
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);

  // 3. Display State: Local state that holds the data currently being shown in the grids.
  // This allows us to show filtered data without modifying the original master data.
  const [displayedClientData, setDisplayedClientData] = useState<DataRow[]>([]);
  const [displayedWorkersData, setDisplayedWorkersData] = useState<DataRow[]>(
    []
  );
  const [displayedTasksData, setDisplayedTasksData] = useState<DataRow[]>([]);

  // --- DATA SYNCHRONIZATION ---

  // This effect hook is crucial. It synchronizes our local 'display' state with the 'master'
  // state from the global store. It runs whenever the master data changes (e.g., after a new file upload).
  // This ensures the grid always shows the latest data if no search filter is active.
  useEffect(() => {
    setDisplayedClientData(clientData);
    setDisplayedWorkersData(workersData);
    setDisplayedTasksData(tasksData);
  }, [clientData, workersData, tasksData]);

  // --- EVENT HANDLERS ---

  /**
   * Handles the AI-powered search functionality.
   * It sends the user's query and data schemas to our backend API,
   * receives a structured filter object, and then applies it to the display state.
   */
  const handleSearch = async () => {
    if (!searchQuery.trim()) return; // Prevent searching on empty input.
    setIsSearching(true);
    try {
      // We pass the column headers (schemas) to the AI so it has context for the user's query.
      const clientSchema =
        clientData.length > 0 ? Object.keys(clientData[0]) : [];
      const workersSchema =
        workersData.length > 0 ? Object.keys(workersData[0]) : [];
      const tasksSchema = tasksData.length > 0 ? Object.keys(tasksData[0]) : [];

      const response = await fetch("/api/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: searchQuery,
          schemas: {
            clients: clientSchema,
            workers: workersSchema,
            tasks: tasksSchema,
          },
        }),
      });

      if (!response.ok)
        throw new Error(`API responded with status: ${response.status}`);

      const result = await response.json();
      console.log("Frontend: Received AI filter object:", result);

      // After receiving the filter object, update the appropriate display state.
      const { target, filters } = result;
      if (target === "clients") {
        setDisplayedClientData(applyFilters(clientData, filters));
      } else if (target === "workers") {
        setDisplayedWorkersData(applyFilters(workersData, filters));
      } else if (target === "tasks") {
        setDisplayedTasksData(applyFilters(tasksData, filters));
      }
    } catch (error) {
      console.error("Frontend: Error during search:", error);
      // In a real app, we might show a user-friendly error message here.
    } finally {
      setIsSearching(false); // Ensure the loading spinner always stops.
    }
  };

  /**
   * Clears any active search filters and resets the display state
   * back to the original master data.
   */
  const handleClear = () => {
    setDisplayedClientData(clientData);
    setDisplayedWorkersData(workersData);
    setDisplayedTasksData(tasksData);
    setSearchQuery("");
  };

  // --- RENDER ---
  return (
    <div className="flex min-h-screen flex-col">
      <Header />
      <div className="flex flex-1">
        <Sidebar />
        <main className="flex-grow p-4">
          {/* Search Bar section */}
          <div className="flex items-center gap-2 mb-4">
            <Input
              placeholder="Search data... (e.g., clients with priority > 3)"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === "Enter") handleSearch();
              }}
            />
            <Button onClick={handleSearch} disabled={isSearching}>
              {isSearching ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Search className="h-4 w-4" />
              )}
            </Button>
            <Button variant="ghost" onClick={handleClear}>
              <X className="h-4 w-4" />
            </Button>
          </div>

          {/* Data Grid Tabs section */}
          <Tabs defaultValue="clients" className="w-full">
            <TabsList className="mb-4">
              <TabsTrigger value="clients">
                Clients ({displayedClientData.length})
              </TabsTrigger>
              <TabsTrigger value="workers">
                Workers ({displayedWorkersData.length})
              </TabsTrigger>
              <TabsTrigger value="tasks">
                Tasks ({displayedTasksData.length})
              </TabsTrigger>
            </TabsList>
            <TabsContent value="clients">
              <DataGrid rowData={displayedClientData} fileType="client" />
            </TabsContent>
            <TabsContent value="workers">
              <DataGrid rowData={displayedWorkersData} fileType="workers" />
            </TabsContent>
            <TabsContent value="tasks">
              <DataGrid rowData={displayedTasksData} fileType="tasks" />
            </TabsContent>
          </Tabs>
        </main>
      </div>
    </div>
  );
}
